
project art/
diff --git a/dex2oat/dex2oat.cc b/dex2oat/dex2oat.cc
index 99616086e1..22cd507fc9 100644
--- a/dex2oat/dex2oat.cc
+++ b/dex2oat/dex2oat.cc
@@ -1284,6 +1284,11 @@ class Dex2Oat final {
 
     // Insert some compiler things.
     InsertCompileOptions(argc, argv);
+    //add
+    if (ArtMethod::IsTuoke()) {
+	    compiler_options_->SetCompilerFilter(CompilerFilter::kVerify);
+    }
+    //add end
   }
 
   // Check whether the oat output files are writable, and open them for later. Also open a swap
diff --git a/runtime/Android.bp b/runtime/Android.bp
index 7bf662c652..d0b253a846 100644
--- a/runtime/Android.bp
+++ b/runtime/Android.bp
@@ -350,6 +350,7 @@ libart_cc_defaults {
                 // ART is allowed to link to libicuuc directly
                 // since they are in the same module
                 "-DANDROID_LINK_SHARED_ICU4C",
+                "-Wno-error"
             ],
         },
         android_arm: {
diff --git a/runtime/art_method.cc b/runtime/art_method.cc
index 0890da8c83..a40b7f17eb 100644
--- a/runtime/art_method.cc
+++ b/runtime/art_method.cc
@@ -51,6 +51,38 @@
 #include "scoped_thread_state_change-inl.h"
 #include "vdex_file.h"
 
+//added code
+
+#include <sys/syscall.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include "runtime.h"
+#include <android/log.h>
+#include <assert.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <pthread.h>
+#include <stdarg.h>
+#include <stddef.h>
+#include <stdlib.h>
+#include <fstream>
+#include <iostream>
+#include <string>
+#include <sys/mman.h>
+#include <sys/socket.h>
+#include <sys/types.h>
+#include <sys/uio.h>
+#include <sys/un.h>
+#include <time.h>
+#include <unistd.h>
+#include <map>
+
+#define gettidv1() syscall(__NR_gettid)
+#define LOG_TAG "ActivityThread"
+#define ALOGI(...) __android_log_print(ANDROID_LOG_INFO, LOG_TAG, __VA_ARGS__)
+//add end
+
 namespace art {
 
 using android::base::StringPrintf;
@@ -64,6 +96,98 @@ extern "C" void art_quick_invoke_static_stub(ArtMethod*, uint32_t*, uint32_t, Th
 static_assert(ArtMethod::kRuntimeMethodDexMethodIndex == dex::kDexNoIndex,
               "Wrong runtime-method dex method index");
 
+typedef struct{
+	char packageName[128];
+	char appName[128];
+	char traceMethod[1024];
+	char debugMethod[1024];
+	bool isTuoke;
+	bool isDeep;
+	bool isInvokePrint;
+	bool isRegisterNativePrint;
+	bool isJNIMethodPrint;
+	int pid;
+	bool init;
+
+}PackageItem;
+
+static PackageItem packageConfig;
+
+static std::map<void*,size_t> dex_map;
+
+const char* ArtMethod::GetTraceMethod(){
+	return packageConfig.traceMethod;
+}
+
+const char* ArtMethod::GetDebugMethod(){
+	return packageConfig.debugMethod;
+}
+
+bool ArtMethod::IsTuoke(){
+	return packageConfig.isTuoke;
+}
+
+bool ArtMethod::IsDeep(){
+	return packageConfig.isDeep;
+}
+
+bool ArtMethod::IsRegisterNativePrint(){
+	return packageConfig.isRegisterNativePrint;
+}
+
+bool ArtMethod::IsJNIMethodPrint(){
+	return packageConfig.isJNIMethodPrint;
+}
+
+bool ArtMethod::IsInvokePrint(){
+	return packageConfig.isInvokePrint;
+}
+
+char* ArtMethod::GetPackageName(){
+	return packageConfig.packageName;
+}
+
+void ArtMethod::SetPackageItem(JNIEnv* env,jobject config){
+    LOG(ERROR)<< "mikrom ArtMethod SetPackageItem enter";
+    //获取Java中的实例类ParamInfo
+    jclass jcInfo = env->FindClass("cn/mik/PackageItem");
+    //获取类中每一个变量的定义
+    //boolean boolValue
+    jfieldID jPackageName = env->GetFieldID(jcInfo, "packageName", "Ljava/lang/String;");
+    jfieldID jAppName = env->GetFieldID(jcInfo, "appName", "Ljava/lang/String;");
+    jfieldID jTraceMethod = env->GetFieldID(jcInfo, "traceMethod", "Ljava/lang/String;");
+    jfieldID jSleepNativeMethod = env->GetFieldID(jcInfo, "sleepNativeMethod", "Ljava/lang/String;");
+    jfieldID jIsTuoke = env->GetFieldID(jcInfo, "isTuoke", "Z");
+    jfieldID jIsDeep = env->GetFieldID(jcInfo, "isDeep", "Z");
+
+    jstring jstrPackageName = (jstring)env->GetObjectField(config, jPackageName);
+    const char* pPackageName = (char*)env->GetStringUTFChars(jstrPackageName, 0);
+    strcpy(packageConfig.packageName, pPackageName);
+
+    jstring jstrAppName = (jstring)env->GetObjectField(config, jAppName);
+    const char* pAppName = (char*)env->GetStringUTFChars(jstrAppName, 0);
+    strcpy(packageConfig.appName, pAppName);
+
+    jstring jstrTraceMethod = (jstring)env->GetObjectField(config, jTraceMethod);
+    const char* pTraceMethod = (char*)env->GetStringUTFChars(jstrTraceMethod, 0);
+    strcpy(packageConfig.traceMethod, pTraceMethod);
+
+    jstring jstrSleepNativeMethod = (jstring)env->GetObjectField(config, jSleepNativeMethod);
+    const char* pSleepNativeMethod = (char*)env->GetStringUTFChars(jstrSleepNativeMethod, 0);
+    strcpy(packageConfig.debugMethod, pSleepNativeMethod);
+
+    packageConfig.isTuoke = env->GetBooleanField(config, jIsTuoke);
+    packageConfig.isDeep = env->GetBooleanField(config, jIsDeep);
+    packageConfig.init=true;
+    packageConfig.isRegisterNativePrint=env->GetBooleanField(config, env->GetFieldID(jcInfo, "isRegisterNativePrint", "Z"));
+    packageConfig.isInvokePrint=env->GetBooleanField(config, env->GetFieldID(jcInfo, "isInvokePrint", "Z"));
+    packageConfig.isJNIMethodPrint=env->GetBooleanField(config, env->GetFieldID(jcInfo, "isJNIMethodPrint", "Z"));
+    std::ostringstream oss;
+    oss << "mikrom SetPackageItem isDeep:"<<packageConfig.isDeep<<" debugMethod:"<<packageConfig.debugMethod<<
+    " traceMethod:"<<packageConfig.traceMethod <<" isJNIMethodPrint:"<<packageConfig.isJNIMethodPrint<<" isRegisterNativePrint:"<<packageConfig.isRegisterNativePrint ;
+    LOG(ERROR)<< oss.str();
+}
+
 ArtMethod* ArtMethod::GetCanonicalMethod(PointerSize pointer_size) {
   if (LIKELY(!IsDefault())) {
     return this;
@@ -78,6 +202,344 @@ ArtMethod* ArtMethod::GetCanonicalMethod(PointerSize pointer_size) {
   }
 }
 
+//add
+uint8_t* codeitem_end(const uint8_t **pData)
+{
+    uint32_t num_of_list = DecodeUnsignedLeb128(pData);
+    for (;num_of_list>0;num_of_list--) {
+        int32_t num_of_handlers=DecodeSignedLeb128(pData);
+        int num=num_of_handlers;
+        if (num_of_handlers<=0) {
+            num=-num_of_handlers;
+        }
+        for (; num > 0; num--) {
+            DecodeUnsignedLeb128(pData);
+            DecodeUnsignedLeb128(pData);
+        }
+        if (num_of_handlers<=0) {
+            DecodeUnsignedLeb128(pData);
+        }
+    }
+    return (uint8_t*)(*pData);
+}
+
+
+
+extern "C" char *base64_encode(char *str,long str_len,long* outlen){
+	long len;
+    char *res;
+    int i,j;
+    const char *base64_table="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
+    if(str_len % 3 == 0)
+        len=str_len/3*4;
+    else
+        len=(str_len/3+1)*4;
+
+    res=(char*)malloc(sizeof(char)*(len+1));
+    res[len]='\0';
+    *outlen=len;
+    for(i=0,j=0;i<len-2;j+=3,i+=4)
+    {
+        res[i]=base64_table[str[j]>>2];
+        res[i+1]=base64_table[(str[j]&0x3)<<4 | (str[j+1]>>4)];
+        res[i+2]=base64_table[(str[j+1]&0xf)<<2 | (str[j+2]>>6)];
+        res[i+3]=base64_table[str[j+2]&0x3f];
+    }
+
+    switch(str_len % 3)
+    {
+        case 1:
+            res[i-2]='=';
+            res[i-1]='=';
+            break;
+        case 2:
+            res[i-1]='=';
+            break;
+    }
+
+    return res;
+	}
+//dumpdexfilebyCookie
+extern "C" void dumpDexOver()  REQUIRES_SHARED(Locks::mutator_lock_) {
+    if(dex_map.size()<=0){
+            LOG(ERROR) << "mikrom dumpDexOver dex_map.size()<=0";
+        return;
+    }
+    char *dexfilepath=(char*)malloc(sizeof(char)*1000);
+    LOG(ERROR) << "mikrom ArtMethod::dumpDexOver";
+    int result=0;
+    char* packageName=ArtMethod::GetPackageName();
+    std::map<void*, size_t>::iterator iter;
+    for(iter = dex_map.begin(); iter != dex_map.end(); iter++) {
+        void* begin_=iter->first;
+        size_t size_=iter->second;
+        int size_int_=(int)size_;
+        memset(dexfilepath,0,1000);
+        sprintf(dexfilepath,"/sdcard/Android/data/%s/files/dump",packageName);
+        mkdir(dexfilepath,0777);
+        memset(dexfilepath,0,1000);
+        sprintf(dexfilepath,"/sdcard/Android/data/%s/files/dump/%d_dexfile_repair.dex",packageName,size_int_);
+        int dexfilefp=open(dexfilepath,O_RDONLY,0666);
+        if(dexfilefp>0){
+          close(dexfilefp);
+          dexfilefp=0;
+
+        }else{
+          int fp=open(dexfilepath,O_CREAT|O_APPEND|O_RDWR,0666);
+          if(fp>0)
+          {
+              result=write(fp,(void*)begin_,size_);
+              if(result<0)
+              {
+                  LOG(ERROR) << "mikrom ArtMethod::dumpDexOver,open dexfilepath error";
+              }
+              fsync(fp);
+              close(fp);
+              memset(dexfilepath,0,1000);
+          }
+        }
+    }
+    if(dexfilepath!=nullptr)
+    {
+        free(dexfilepath);
+        dexfilepath=nullptr;
+    }
+}
+    //在函数即将调用解释器执行前进行dump。
+extern "C" void dumpdexfilebyExecute(ArtMethod* artmethod)  REQUIRES_SHARED(Locks::mutator_lock_) {
+    if(artmethod==nullptr){
+        LOG(ERROR)<< "mikrom ArtMethod::dumpdexfilebyExecute artmethod is null";
+        return;
+    }
+    char *dexfilepath=(char*)malloc(sizeof(char)*1000);
+    if(dexfilepath==nullptr)
+    {
+            std::ostringstream oss;
+            oss<<"mikrom ArtMethod::dumpdexfilebyArtMethod,methodname:"<<artmethod->PrettyMethod().c_str()<<"malloc 1000 byte failed";
+        LOG(ERROR)<< oss.str();
+        return;
+    }
+    int result=0;
+    char* packageName=ArtMethod::GetPackageName();
+    const DexFile* dex_file = artmethod->GetDexFile();
+    if(dex_file==nullptr){
+        LOG(ERROR)<< "mikrom ArtMethod::dumpdexfilebyExecute dex_file is null";
+        return;
+    }
+    const uint8_t* begin_=dex_file->Begin();  // Start of data.
+    size_t size_=dex_file->Size();  // Length of data.
+
+    memset(dexfilepath,0,1000);
+    int size_int_=(int)size_;
+
+    memset(dexfilepath,0,1000);
+    sprintf(dexfilepath,"/sdcard/Android/data/%s/files/dump",packageName);
+    mkdir(dexfilepath,0777);
+    memset(dexfilepath,0,1000);
+    sprintf(dexfilepath,"/sdcard/Android/data/%s/files/dump/%d_dexfile_execute.dex",packageName,size_int_);
+    int dexfilefp=open(dexfilepath,O_RDONLY,0666);
+    if(dexfilefp>0){
+      close(dexfilefp);
+      dexfilefp=0;
+
+      }else{
+              int fp=open(dexfilepath,O_CREAT|O_APPEND|O_RDWR,0666);
+              if(fp>0)
+              {
+                  result=write(fp,(void*)begin_,size_);
+                  if(result<0)
+                  {
+                    LOG(ERROR) << "mikrom ArtMethod::dumpdexfilebyArtMethod,open dexfilepath error";
+                  }
+                  fsync(fp);
+                  close(fp);
+                  memset(dexfilepath,0,1000);
+                  sprintf(dexfilepath,"/sdcard/Android/data/%s/files/dump/%d_classlist_execute.txt",packageName,size_int_);
+                  int classlistfile=open(dexfilepath,O_CREAT|O_APPEND|O_RDWR,0666);
+                  if(classlistfile>0)
+                  {
+                        for (size_t ii= 0; ii< dex_file->NumClassDefs(); ++ii)
+                        {
+                            const dex::ClassDef& class_def = dex_file->GetClassDef(ii);
+                            const char* descriptor = dex_file->GetClassDescriptor(class_def);
+                            result=write(classlistfile,(void*)descriptor,strlen(descriptor));
+                            if(result<0)
+                            {
+                                LOG(ERROR) << "mikrom ArtMethod::dumpdexfilebyExecute,write classlistfile file error";
+                            }
+                            const char* temp="\n";
+                            result=write(classlistfile,(void*)temp,1);
+                            if(result<0)
+                            {
+                                LOG(ERROR) << "mikrom ArtMethod::dumpdexfilebyExecute,write classlistfile file error";
+                            }
+                            fsync(classlistfile);
+                            close(classlistfile);
+
+                        }
+                  }
+              }
+      }
+      if(dexfilepath!=nullptr)
+      {
+          free(dexfilepath);
+          dexfilepath=nullptr;
+      }
+}
+
+//主动调用函数的dump处理
+extern "C" void dumpArtMethod(ArtMethod* artmethod)  REQUIRES_SHARED(Locks::mutator_lock_) {
+            //LOG(ERROR) << "mikrom ArtMethod::dumpArtMethod "<<artmethod->PrettyMethod().c_str();
+            char *dexfilepath=(char*)malloc(sizeof(char)*1000);
+            if(dexfilepath==nullptr)
+            {
+                std::ostringstream oss;
+                oss<<"mikrom ArtMethod::dumpArtMethodinvoked,methodname:"<<artmethod->PrettyMethod().c_str()<<"malloc 1000 byte failed";
+                LOG(ERROR) << oss.str();
+                return;
+            }
+            int result=0;
+            char* packageName=ArtMethod::GetPackageName();
+                const DexFile* dex_file = artmethod->GetDexFile();
+                const uint8_t* begin_=dex_file->Begin();  // Start of data.
+                size_t size_=dex_file->Size();  // Length of data.
+
+                memset(dexfilepath,0,1000);
+                int size_int_=(int)size_;
+
+                memset(dexfilepath,0,1000);
+                sprintf(dexfilepath,"/sdcard/Android/data/%s/files/dump",packageName);
+                mkdir(dexfilepath,0777);
+                memset(dexfilepath,0,1000);
+                const char* deepstr="";
+                if(ArtMethod::IsDeep()){
+                     deepstr="_deep";
+                }
+                sprintf(dexfilepath,"/sdcard/Android/data/%s/files/dump/%d%s_dexfile.dex",packageName,size_int_,deepstr);
+                int dexfilefp=open(dexfilepath,O_RDONLY,0666);
+                if(dexfilefp>0){
+                    close(dexfilefp);
+                    dexfilefp=0;
+                }else{
+                    LOG(ERROR) << "mikrom ArtMethod::dumpdexfilebyArtMethod save dex_map";
+                    dex_map.insert(std::pair<void*,size_t>((void*)begin_,size_));
+                    int fp=open(dexfilepath,O_CREAT|O_APPEND|O_RDWR,0666);
+                    if(fp>0)
+                    {
+                            result=write(fp,(void*)begin_,size_);
+                            if(result<0)
+                            {
+                                 LOG(ERROR) << "mikrom ArtMethod::dumpdexfilebyArtMethod,open dexfilepath file error";
+                            }
+                            fsync(fp);
+                            close(fp);
+                            memset(dexfilepath,0,1000);
+                            sprintf(dexfilepath,"/sdcard/Android/data/%s/files/dump/%d%s_classlist.txt",packageName,size_int_,deepstr);
+                            int classlistfile=open(dexfilepath,O_CREAT|O_APPEND|O_RDWR,0666);
+                            if(classlistfile>0)
+                            {
+                                        for (size_t ii= 0; ii< dex_file->NumClassDefs(); ++ii)
+                                        {
+                                                const dex::ClassDef& class_def = dex_file->GetClassDef(ii);
+                                                const char* descriptor = dex_file->GetClassDescriptor(class_def);
+                                                result=write(classlistfile,(void*)descriptor,strlen(descriptor));
+                                                if(result<0)
+                                                {
+                                                        LOG(ERROR) << "mikrom ArtMethod::dumpdexfilebyArtMethod,write classlistfile file error";
+
+                                                        }
+                                                const char* temp="\n";
+                                                result=write(classlistfile,(void*)temp,1);
+                                                if(result<0)
+                                                {
+                                                        LOG(ERROR) << "mikrom ArtMethod::dumpdexfilebyArtMethod,write classlistfile file error";
+
+                                                }
+                                        }
+                                        fsync(classlistfile);
+                                        close(classlistfile);
+                            }
+                    }
+                }
+
+                const dex::CodeItem* code_item = artmethod->GetCodeItem();
+                const DexFile* dex_=artmethod->GetDexFile();
+                CodeItemDataAccessor accessor(*dex_, dex_->GetCodeItem(artmethod->GetCodeItemOffset()));
+                if (LIKELY(code_item != nullptr))
+                {
+                            //LOG(ERROR) << "mikrom dumpArtMethodinvoked,methodname:"<<artmethod->PrettyMethod().c_str()<<" write bin";
+                            int code_item_len = 0;
+                            uint8_t *item=(uint8_t *) code_item;
+                            if (accessor.TriesSize()>0) {
+                                    const uint8_t *handler_data = accessor.GetCatchHandlerData();
+                                    uint8_t * tail = codeitem_end(&handler_data);
+                                    code_item_len = (int)(tail - item);
+                            }else{
+                                    code_item_len = 16+accessor.InsnsSizeInCodeUnits()*2;
+                            }
+                            memset(dexfilepath,0,1000);
+                            int size_int=(int)dex_file->Size();
+                            uint32_t method_idx=artmethod->GetDexMethodIndex();
+                            sprintf(dexfilepath,"/sdcard/Android/data/%s/files/dump/%d%s_ins_%d.bin",packageName,size_int,deepstr,(int)gettidv1());
+                            int fp2=open(dexfilepath,O_CREAT|O_APPEND|O_RDWR,0666);
+                            if(fp2>0){
+                                    lseek(fp2,0,SEEK_END);
+                                    memset(dexfilepath,0,1000);
+                                    int offset=(int)(item - begin_);
+                                    sprintf(dexfilepath,"{name:%s,method_idx:%d,offset:%d,code_item_len:%d,ins:",artmethod->PrettyMethod().c_str(),method_idx,offset,code_item_len);
+                                    int contentlength=0;
+                                    while(dexfilepath[contentlength]!=0) contentlength++;
+                                    result=write(fp2,(void*)dexfilepath,contentlength);
+                                    if(result<0)
+                                    {
+                                            LOG(ERROR) << "mikrom ArtMethod::dumpdexfilebyArtMethod,write ins file error";
+                                    }
+                                    long outlen=0;
+                                    char* base64result=base64_encode((char*)item,(long)code_item_len,&outlen);
+                                    result=write(fp2,base64result,outlen);
+                                    if(result<0){
+                                            LOG(ERROR) << "mikrom ArtMethod::dumpdexfilebyArtMethod,write ins file error";
+                                    }
+                                    result=write(fp2,"};",2);
+                                    if(result<0){
+                                         LOG(ERROR) << "mikrom ArtMethod::dumpdexfilebyArtMethod,write ins file error";
+                                    }
+                                    fsync(fp2);
+                                    close(fp2);
+                                    if(base64result!=nullptr){
+                                            free(base64result);
+                                            base64result=nullptr;
+                                    }
+                            }
+                }
+            if(dexfilepath!=nullptr)
+            {
+                free(dexfilepath);
+                dexfilepath=nullptr;
+            }
+            //LOG(ERROR) << "mikrom ArtMethod::dumpArtMethod over "<<artmethod->PrettyMethod().c_str();
+}
+extern "C" void fartextInvoke(ArtMethod* artmethod)  REQUIRES_SHARED(Locks::mutator_lock_) {
+    if(artmethod->IsNative()||artmethod->IsAbstract()){
+        return;
+    }
+    JValue result;
+    Thread *self=Thread::Current();
+    uint32_t temp[100]={0};
+    uint32_t* args=temp;
+    uint32_t args_size = (uint32_t)ArtMethod::NumArgRegisters(artmethod->GetShorty());
+    if (!artmethod->IsStatic()) {
+      args_size += 1;
+    }
+    result.SetI(111111);
+    artmethod->Invoke(self, args, args_size, &result,artmethod->GetShorty());
+}
+
+
+
+
+//addend
+
 ArtMethod* ArtMethod::GetNonObsoleteMethod() {
   if (LIKELY(!IsObsolete())) {
     return this;
@@ -306,6 +768,22 @@ void ArtMethod::Invoke(Thread* self, uint32_t* args, uint32_t args_size, JValue*
     ThrowStackOverflowError(self);
     return;
   }
+//add
+		if ((result!=nullptr && result->GetI()==111111)){
+			if(!ArtMethod::IsDeep()){
+					dumpArtMethod(this);
+					return;
+			}
+
+		}
+		//else{
+		//	if(ArtMethod::IsInvokePrint()){
+		//				std::ostringstream oss;
+		//				oss<<"mikrom art invoke "<<this->PrettyMethod().c_str();
+		//				LOG(ERROR) <<oss.str();
+		//		}
+		//}
+	//add end
 
   if (kIsDebugBuild) {
     self->AssertThreadSuspensionIsAllowable();
@@ -322,6 +800,27 @@ void ArtMethod::Invoke(Thread* self, uint32_t* args, uint32_t args_size, JValue*
   // If the runtime is not yet started or it is required by the debugger, then perform the
   // Invocation by the interpreter, explicitly forcing interpretation over JIT to prevent
   // cycling around the various JIT/Interpreter methods that handle method invocation.
+
+  //add
+
+  if ((result!=nullptr && result->GetI()==111111)&&!IsNative()){
+	const dex::CodeItem* code_item =this->GetCodeItem();
+	if(LIKELY(code_item!=nullptr)){
+			if (IsStatic()) {
+				art::interpreter::EnterInterpreterFromInvoke(
+												self, this, nullptr, args, result, /*stay_in_interpreter=*/ true);
+			}else{
+				art::interpreter::EnterInterpreterFromInvoke(
+									self, this, nullptr, args + 1, result, /*stay_in_interpreter=*/ true);
+			}
+			self->PopManagedStackFragment(fragment);
+	}
+	return;
+  }
+  //add end
+
+
+
   if (UNLIKELY(!runtime->IsStarted() ||
                (self->IsForceInterpreter() && !IsNative() && !IsProxyMethod() && IsInvokable()) ||
                Dbg::IsForcedInterpreterNeededForCalling(self, this))) {
diff --git a/runtime/art_method.h b/runtime/art_method.h
index 83213d5f0c..9330fec59b 100644
--- a/runtime/art_method.h
+++ b/runtime/art_method.h
@@ -82,6 +82,16 @@ class ArtMethod final {
   ArtMethod(ArtMethod* src, PointerSize image_pointer_size) {
     CopyFrom(src, image_pointer_size);
   }
+  
+  static bool IsInvokePrint() REQUIRES_SHARED(Locks::mutator_lock_);
+  static bool IsJNIMethodPrint() REQUIRES_SHARED(Locks::mutator_lock_);
+  static bool IsRegisterNativePrint() REQUIRES_SHARED(Locks::mutator_lock_);
+  static const char* GetTraceMethod() REQUIRES_SHARED(Locks::mutator_lock_);
+  static const char* GetDebugMethod() REQUIRES_SHARED(Locks::mutator_lock_);
+  static bool IsTuoke() ;
+  static bool IsDeep() REQUIRES_SHARED(Locks::mutator_lock_);
+  static char* GetPackageName() REQUIRES_SHARED(Locks::mutator_lock_);
+  static void SetPackageItem(JNIEnv* env,jobject config);
 
   static ArtMethod* FromReflectedMethod(const ScopedObjectAccessAlreadyRunnable& soa,
                                         jobject jlr_method)
diff --git a/runtime/class_linker.cc b/runtime/class_linker.cc
index 9575546951..623aed853f 100644
--- a/runtime/class_linker.cc
+++ b/runtime/class_linker.cc
@@ -3494,6 +3494,13 @@ static void LinkCode(ClassLinker* class_linker,
   // Install entry point from interpreter.
   const void* quick_code = method->GetEntryPointFromQuickCompiledCode();
   bool enter_interpreter = class_linker->ShouldUseInterpreterEntrypoint(method, quick_code);
+  
+  //add
+  if (strlen(ArtMethod::GetTraceMethod())>0) {
+  	enter_interpreter=true;
+  
+  }
+  //add end
 
   if (!method->IsInvokable()) {
     EnsureThrowsInvocationError(class_linker, method);
diff --git a/runtime/interpreter/interpreter.cc b/runtime/interpreter/interpreter.cc
index db116f5a63..9a50c48d80 100644
--- a/runtime/interpreter/interpreter.cc
+++ b/runtime/interpreter/interpreter.cc
@@ -38,6 +38,11 @@
 #include "unstarted_runtime.h"
 
 namespace art {
+
+//add
+extern "C" void dumpdexfilebyExecute(ArtMethod* artmethod);
+//addend
+
 namespace interpreter {
 
 ALWAYS_INLINE static ObjPtr<mirror::Object> ObjArg(uint32_t arg)
@@ -319,6 +324,23 @@ static inline JValue Execute(
   // Lock counting is a special version of accessibility checks, and for simplicity and
   // reduction of template parameters, we gate it behind access-checks mode.
   DCHECK(!method->SkipAccessChecks() || !method->MustCountLocks());
+  //add
+
+  if((result_register.GetI()==111111)){
+    return ExecuteSwitchImpl<false, false>(self, accessor, shadow_frame, result_register,false);
+  }
+  if(ArtMethod::GetTraceMethod()!=nullptr && strlen(ArtMethod::GetTraceMethod())>0){
+
+	if(strstr(method->PrettyMethod().c_str(),ArtMethod::GetTraceMethod())){
+		std::ostringstream oss;
+		oss<< "mikrom Execute strstr:"<<method->PrettyMethod().c_str()<<"\t"<<ArtMethod::GetTraceMethod();
+		LOG(ERROR) <<oss.str();
+		return ExecuteSwitchImpl<false, false>(self, accessor, shadow_frame, result_register,false);
+	}
+  }
+
+  //add end
+
 
   bool transaction_active = Runtime::Current()->IsActiveTransaction();
   if (LIKELY(method->SkipAccessChecks())) {
@@ -445,8 +467,16 @@ void EnterInterpreterFromInvoke(Thread* self,
 
   size_t cur_reg = num_regs - num_ins;
   if (!method->IsStatic()) {
+	//add
+	if(result!=nullptr&&result->GetI()==111111){
+		shadow_frame->SetVReg(cur_reg, args[0]);
+	}else{
+		CHECK(receiver != nullptr);
+		shadow_frame->SetVRegReference(cur_reg, receiver);
+	}
+	//add end
     CHECK(receiver != nullptr);
-    shadow_frame->SetVRegReference(cur_reg, receiver);
+    //shadow_frame->SetVRegReference(cur_reg, receiver);
     ++cur_reg;
   }
   uint32_t shorty_len = 0;
@@ -455,6 +485,12 @@ void EnterInterpreterFromInvoke(Thread* self,
     DCHECK_LT(shorty_pos + 1, shorty_len);
     switch (shorty[shorty_pos + 1]) {
       case 'L': {
+	//add
+	if(result!=nullptr&&result->GetI()==111111){
+		shadow_frame->SetVReg(cur_reg, args[0]);
+		break;
+	}
+	//add end
         ObjPtr<mirror::Object> o =
             reinterpret_cast<StackReference<mirror::Object>*>(&args[arg_pos])->AsMirrorPtr();
         shadow_frame->SetVRegReference(cur_reg, o);
@@ -485,10 +521,25 @@ void EnterInterpreterFromInvoke(Thread* self,
     }
   }
   if (LIKELY(!method->IsNative())) {
-    JValue r = Execute(self, accessor, *shadow_frame, JValue(), stay_in_interpreter);
-    if (result != nullptr) {
-      *result = r;
+	  //add
+    if(result!=nullptr&&result->GetI()==111111){
+        JValue r = Execute(self, accessor, *shadow_frame, *result, stay_in_interpreter);
+        if (result != nullptr) {
+          *result = r;
+        }
+        //LOG(ERROR) << "fartext Execute over"<<method->PrettyMethod().c_str();
+        return;
+    }else{
+        JValue r = Execute(self, accessor, *shadow_frame, JValue(), stay_in_interpreter);
+        if (result != nullptr) {
+          *result = r;
+        }
     }
+	  //add end
+   // JValue r = Execute(self, accessor, *shadow_frame, JValue(), stay_in_interpreter);
+   // if (result != nullptr) {
+   //   *result = r;
+   // }
   } else {
     // We don't expect to be asked to interpret native code (which is entered via a JNI compiler
     // generated stub) except during testing and image writing.
diff --git a/runtime/interpreter/interpreter_common.h b/runtime/interpreter/interpreter_common.h
index 6366035a4c..6906550a6b 100644
--- a/runtime/interpreter/interpreter_common.h
+++ b/runtime/interpreter/interpreter_common.h
@@ -584,28 +584,31 @@ constexpr bool kTraceExecutionEnabled = false;
 static inline void TraceExecution(const ShadowFrame& shadow_frame, const Instruction* inst,
                                   const uint32_t dex_pc)
     REQUIRES_SHARED(Locks::mutator_lock_) {
-  if (kTraceExecutionEnabled) {
-#define TRACE_LOG std::cerr
-    std::ostringstream oss;
-    oss << shadow_frame.GetMethod()->PrettyMethod()
-        << android::base::StringPrintf("\n0x%x: ", dex_pc)
-        << inst->DumpString(shadow_frame.GetMethod()->GetDexFile()) << "\n";
-    for (uint32_t i = 0; i < shadow_frame.NumberOfVRegs(); ++i) {
-      uint32_t raw_value = shadow_frame.GetVReg(i);
-      ObjPtr<mirror::Object> ref_value = shadow_frame.GetVRegReference(i);
-      oss << android::base::StringPrintf(" vreg%u=0x%08X", i, raw_value);
-      if (ref_value != nullptr) {
-        if (ref_value->GetClass()->IsStringClass() &&
-            !ref_value->AsString()->IsValueNull()) {
-          oss << "/java.lang.String \"" << ref_value->AsString()->ToModifiedUtf8() << "\"";
-        } else {
-          oss << "/" << ref_value->PrettyTypeOf();
+    //strstr(ArtMethod::GetTraceMethod(),shadow_frame.GetMethod()->PrettyMethod().c_str())
+
+    if(shadow_frame.GetMethod()!=nullptr && ArtMethod::GetTraceMethod()!=nullptr&&strlen(ArtMethod::GetTraceMethod())>0){
+        const char* methodName=shadow_frame.GetMethod()->PrettyMethod().c_str();
+        if(strstr(methodName,ArtMethod::GetTraceMethod())) {
+            std::ostringstream oss;
+                    oss << android::base::StringPrintf("mikrom smaliTrace 0x%x: ", dex_pc)
+                            << inst->DumpString(shadow_frame.GetMethod()->GetDexFile()) << "\t//";
+                    for (uint32_t i = 0; i < shadow_frame.NumberOfVRegs(); ++i) {
+                        uint32_t raw_value = shadow_frame.GetVReg(i);
+                        ObjPtr<mirror::Object> ref_value = shadow_frame.GetVRegReference(i);
+                        oss << android::base::StringPrintf(" vreg%u=0x%08X", i, raw_value);
+                        if (ref_value != nullptr) {
+                            if (ref_value->GetClass()->IsStringClass() &&
+                                    !ref_value->AsString()->IsValueNull()) {
+                                oss << "/java.lang.String \"" << ref_value->AsString()->ToModifiedUtf8() << "\"";
+                            } else {
+                                oss << "/" << ref_value->PrettyTypeOf();
+                            }
+                        }
+                    }
+                    LOG(ERROR)<<oss.str();
         }
-      }
     }
-    TRACE_LOG << oss.str() << "\n";
-#undef TRACE_LOG
-  }
+
 }
 
 static inline bool IsBackwardBranch(int32_t branch_offset) {
diff --git a/runtime/interpreter/interpreter_switch_impl-inl.h b/runtime/interpreter/interpreter_switch_impl-inl.h
index 36cfee418e..5e6face3b7 100644
--- a/runtime/interpreter/interpreter_switch_impl-inl.h
+++ b/runtime/interpreter/interpreter_switch_impl-inl.h
@@ -40,6 +40,9 @@
 #include "verifier/method_verifier.h"
 
 namespace art {
+
+extern "C" void dumpArtMethod(ArtMethod* artmethod);
+
 namespace interpreter {
 
 // Short-lived helper class which executes single DEX bytecode.  It is inlined by compiler.
@@ -2641,6 +2644,13 @@ ATTRIBUTE_NO_SANITIZE_ADDRESS void ExecuteSwitchImplCpp(SwitchImplContext* ctx)
 
   DCHECK(!shadow_frame.GetForceRetryInstruction())
       << "Entered interpreter from invoke without retry instruction being handled!";
+  
+  //add
+  int32_t regvalue=ctx->result_register.GetI();
+  ctx->result_register=JValue();
+  int inst_count = -1;
+  bool flag=false;
+  //add end
 
   bool const interpret_one_instruction = ctx->interpret_one_instruction;
   while (true) {
@@ -2662,6 +2672,37 @@ ATTRIBUTE_NO_SANITIZE_ADDRESS void ExecuteSwitchImplCpp(SwitchImplContext* ctx)
         continue;
       }
     }
+    
+    
+    //add
+    inst_count++;
+    uint8_t opcode = inst->Opcode(inst_data);
+    if(regvalue==111111){
+        if(inst_count == 0){
+            if(opcode == Instruction::GOTO || opcode == Instruction::GOTO_16 || opcode == Instruction::GOTO_32){
+                LOG(ERROR) << "mikrom ExecuteSwitchImplCpp Switch inst_count=0 opcode==GOTO "<<shadow_frame.GetMethod()->PrettyMethod().c_str();
+                flag=true;
+            }
+            else{
+                //LOG(ERROR) << "mikrom ExecuteSwitchImplCpp Switch inst_count=0 opcode!=GOTO "<<shadow_frame.GetMethod()->PrettyMethod().c_str();
+                dumpArtMethod(shadow_frame.GetMethod());
+                break;
+            }
+        }
+        if(inst_count == 1){
+            if(opcode >= Instruction::CONST_4 && opcode <= Instruction::CONST_WIDE_HIGH16){
+                //LOG(ERROR) << "mikrom ExecuteSwitchImplCpp Switch inst_count=1 opcode==CONST "<<shadow_frame.GetMethod()->PrettyMethod().c_str();
+                flag=true;
+            }else{
+                //LOG(ERROR) << "mikrom ExecuteSwitchImplCpp Switch inst_count=1 opcode!=CONST "<<shadow_frame.GetMethod()->PrettyMethod().c_str();
+                dumpArtMethod(shadow_frame.GetMethod());
+                break;
+            }
+        }
+    }
+    //add end
+    
+    
     switch (inst->Opcode(inst_data)) {
 #define OPCODE_CASE(OPCODE, OPCODE_NAME, pname, f, i, a, e, v)                                    \
       case OPCODE: {                                                                              \
@@ -2678,6 +2719,24 @@ ATTRIBUTE_NO_SANITIZE_ADDRESS void ExecuteSwitchImplCpp(SwitchImplContext* ctx)
 DEX_INSTRUCTION_LIST(OPCODE_CASE)
 #undef OPCODE_CASE
     }
+    
+    //add
+    if(regvalue==111111){
+        if(inst_count==2&&flag){
+            if(opcode == Instruction::INVOKE_STATIC || opcode == Instruction::INVOKE_STATIC_RANGE){
+                LOG(ERROR) << "mikrom ExecuteSwitchImplCpp Switch INVOKE_STATIC over "<<shadow_frame.GetMethod()->PrettyMethod().c_str();
+                dumpArtMethod(shadow_frame.GetMethod());
+                break;
+            }
+        }
+        if(inst_count>2){
+            LOG(ERROR) << "mikrom ExecuteSwitchImplCpp Switch inst_count>2 " <<shadow_frame.GetMethod()->PrettyMethod().c_str();
+            dumpArtMethod(shadow_frame.GetMethod());
+            break;
+        }
+    }
+    //add end
+    
     if (UNLIKELY(interpret_one_instruction)) {
       break;
     }
diff --git a/runtime/native/dalvik_system_DexFile.cc b/runtime/native/dalvik_system_DexFile.cc
index eee8cfc620..1624777719 100644
--- a/runtime/native/dalvik_system_DexFile.cc
+++ b/runtime/native/dalvik_system_DexFile.cc
@@ -52,8 +52,20 @@
 #include "scoped_thread_state_change-inl.h"
 #include "well_known_classes.h"
 
+//add
+#include "scoped_fast_native_object_access.h"
+//add end
+// change mikrom
+
 namespace art {
 
+//add
+extern "C" void fartextInvoke(ArtMethod* artmethod);
+extern "C" ArtMethod* jobject2ArtMethod(JNIEnv* env, jobject javaMethod);
+extern "C" void dumpDexOver();
+
+//add end
+
 using android::base::StringPrintf;
 
 static bool ConvertJavaArrayToDexFiles(
@@ -521,6 +533,30 @@ static jobjectArray DexFile_getClassNameList(JNIEnv* env, jclass, jobject cookie
   return result;
 }
 
+static jboolean DexFile_setMikRomConfig(JNIEnv* env,jclass,jobject config){
+    ArtMethod::SetPackageItem(env,config);
+    return JNI_TRUE;
+}
+
+//addfunction 将ava的Method转换成ArtMethod。然后主动调用
+static void DexFile_fartextMethodCode(JNIEnv* env, jclass,jobject method) {
+  if(method!=nullptr)
+  {
+      ArtMethod* proxy_method = jobject2ArtMethod(env, method);
+      fartextInvoke(proxy_method);
+  }
+  return;
+}
+
+static void DexFile_dumpRepair(JNIEnv* env, jclass){
+    if(env==nullptr){
+        return;
+    }
+    dumpDexOver();
+}
+
+
+
 static jint GetDexOptNeeded(JNIEnv* env,
                             const char* filename,
                             const char* instruction_set,
@@ -950,7 +986,13 @@ static JNINativeMethod gMethods[] = {
   NATIVE_METHOD(DexFile, getStaticSizeOfDexFile, "(Ljava/lang/Object;)J"),
   NATIVE_METHOD(DexFile, getDexFileOptimizationStatus,
                 "(Ljava/lang/String;Ljava/lang/String;)[Ljava/lang/String;"),
-  NATIVE_METHOD(DexFile, setTrusted, "(Ljava/lang/Object;)V")
+  NATIVE_METHOD(DexFile, setTrusted, "(Ljava/lang/Object;)V"),
+  //add
+  NATIVE_METHOD(DexFile, fartextMethodCode,"(Ljava/lang/Object;)V"),
+  NATIVE_METHOD(DexFile, dumpRepair,"()V"),
+  NATIVE_METHOD(DexFile, setMikRomConfig,"(Ljava/lang/Object;)Z")
+
+  //add end
 };
 
 void register_dalvik_system_DexFile(JNIEnv* env) {
diff --git a/runtime/native/java_lang_reflect_Method.cc b/runtime/native/java_lang_reflect_Method.cc
index 4525157d6e..999de5cb1a 100644
--- a/runtime/native/java_lang_reflect_Method.cc
+++ b/runtime/native/java_lang_reflect_Method.cc
@@ -35,6 +35,14 @@
 
 namespace art {
 
+//add
+extern "C" ArtMethod* jobject2ArtMethod(JNIEnv* env, jobject javaMethod) {
+  ScopedFastNativeObjectAccess soa(env);
+  ArtMethod* method = ArtMethod::FromReflectedMethod(soa, javaMethod);
+  return method;
+}
+//add end
+
 static jobject Method_getDefaultValue(JNIEnv* env, jobject javaMethod) {
   ScopedFastNativeObjectAccess soa(env);
   ArtMethod* method = ArtMethod::FromReflectedMethod(soa, javaMethod);
